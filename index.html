<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>AR Style Voxel Game</title>
    <style>
      /* Base styles for body and layout */
      html,
      body {
        margin: 0;
        padding: 0;
        height: 100%;
        width: 100%;
        overflow: hidden;
        background: #000;
        font-family: sans-serif;
        touch-action: none; /* prevent default gestures */
      }

      /* Container holds video/canvas and UI overlay */
      #container {
        position: relative;
        width: 100%;
        height: 100%;
      }

      /* Video element for camera background */
      #camera {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        object-fit: cover;
        background: #202020;
      }

      /* Fallback overlay if camera is unavailable */
      #fallback {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: linear-gradient(135deg, #36475c, #5a6379);
        opacity: 0.6;
        display: none;
      }

      /* Canvas for voxel rendering */
      #gameCanvas {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        touch-action: none;
      }

      /* Toolbar UI */
      #toolbar {
        position: absolute;
        bottom: 10px;
        left: 50%;
        transform: translateX(-50%);
        display: flex;
        gap: 10px;
        background: rgba(0, 0, 0, 0.5);
        padding: 8px 12px;
        border-radius: 8px;
        backdrop-filter: blur(4px);
      }

      #toolbar button {
        border: none;
        padding: 8px 12px;
        border-radius: 4px;
        font-size: 14px;
        cursor: pointer;
        color: #fff;
        background: rgba(255, 255, 255, 0.2);
        outline: none;
        transition: background 0.2s;
      }

      #toolbar button.active {
        background: rgba(255, 255, 255, 0.6);
        color: #000;
      }

      #status {
        position: absolute;
        top: 10px;
        left: 10px;
        color: #fff;
        font-size: 12px;
        background: rgba(0, 0, 0, 0.4);
        padding: 4px 8px;
        border-radius: 4px;
        pointer-events: none;
      }

      /* Orientation ball indicator */
      #orientBall {
        position: absolute;
        top: 10px;
        right: 10px;
        width: 60px;
        height: 60px;
        pointer-events: auto;
        cursor: pointer;
        z-index: 12;
      }

      /* Zoom control ball indicator.  This ball allows users to adjust the camera
         distance by dragging the red dot horizontally.  The dot represents
         the current zoom level between the minimum and maximum distances.
         Placed just below the orientation ball to align controls visually. */
      #zoomBall {
        position: absolute;
        top: 80px; /* place below the orientation ball */
        right: 10px;
        width: 60px;
        height: 60px;
        pointer-events: auto;
        cursor: pointer;
        z-index: 12;
      }

      /* Tilt slider styling.  Positioned below the zoom ball and sized to align with
         the control balls.  The slider allows users to adjust camera pitch
         (up/down tilt) independently from the zoom ball. */
      #tiltSlider {
        position: absolute;
        top: 150px; /* place below the zoom ball */
        right: 10px;
        width: 60px;
        pointer-events: auto;
        z-index: 12;
      }

      /* Height display styling */
      #heightDisplay {
        color: #fff;
        display: flex;
        align-items: center;
        padding: 0 6px;
        font-size: 14px;
      }

  /* Camera prompt overlay to request user permission for AR */
  #cameraPrompt {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0.75);
    display: none;
    align-items: center;
    justify-content: center;
    flex-direction: column;
    color: #fff;
    z-index: 20;
    text-align: center;
    padding: 20px;
  }
  #cameraPrompt button {
    margin-top: 12px;
    padding: 10px 20px;
    font-size: 16px;
    border: none;
    border-radius: 6px;
    background: rgba(255, 255, 255, 0.8);
    color: #000;
    cursor: pointer;
  }
      /* Mobile menu button and collapsible toolbar for small screens */
      #menuButton {
        position: absolute;
        bottom: 10px;
        left: 10px;
        width: 44px;
        height: 44px;
        border: none;
        border-radius: 6px;
        font-size: 24px;
        color: #fff;
        background: rgba(0, 0, 0, 0.5);
        z-index: 10;
        display: none;
      }
      @media (max-width: 600px) {
        #menuButton {
          display: block;
        }
        /* Collapse the toolbar by default on small screens. Expanded state is toggled via JS. */
        #toolbar {
          position: absolute;
          bottom: 0;
          left: 0;
          width: 100%;
          transform: none;
          max-height: 0;
          padding: 0;
          opacity: 0;
          pointer-events: none;
          transition: max-height 0.3s ease, opacity 0.3s ease;
        }
        /* When expanded on small screens, display as a popup overlay from the bottom.
           The toolbar wraps items onto multiple rows and can scroll vertically. */
        #toolbar.expanded {
          max-height: 60vh;
          padding: 8px 10px;
          opacity: 1;
          pointer-events: auto;
          overflow-y: auto;
          overflow-x: hidden;
          flex-wrap: wrap;
        }
      }
      @media (min-width: 601px) {
        #menuButton {
          display: none;
        }
      }
    </style>
  </head>
  <body>
    <div id="container">
      <video id="camera" autoplay playsinline muted></video>
      <div id="fallback"></div>
      <canvas id="gameCanvas"></canvas>
      <div id="status">Initializing...</div>
      <!-- Orientation ball: displays current yaw/pitch orientation -->
      <canvas id="orientBall" width="60" height="60"></canvas>
      <!-- Zoom ball: controls camera distance via dragging. Shows current zoom level. -->
      <canvas id="zoomBall" width="60" height="60"></canvas>
      <!-- Tilt slider: controls the camera pitch (tilt) independently of the zoom ball. -->
      <input type="range" id="tiltSlider" min="-80" max="80" value="-30" step="1" />
      <!-- Prompt asking the user to enable camera. Initially hidden until needed. -->
      <div id="cameraPrompt">
        <p>Please enable your camera to overlay blocks in AR. Depending on your browser, camera access may require a secure (https) context or explicit permission. If your camera prompt does not appear, try hosting this file on a local web server or enabling permissions in your browser settings.</p>
        <button id="cameraButton">Enable Camera</button>
      </div>
      <!-- Menu button for mobile view -->
      <button id="menuButton">☰</button>
      <div id="toolbar">
        <!-- Block type buttons -->
        <button data-type="grass" class="active">Grass</button>
        <button data-type="stone">Stone</button>
        <button data-type="glass">Glass</button>
        <button data-type="wood">Wood</button>
        <button data-type="brick">Brick</button>
        <button data-type="road">Road</button>
        <button data-type="sand">Sand</button>
        <button data-type="water">Water</button>
        <button data-type="roof">Roof</button>
        <!-- Additional block types for richer constructions -->
        <button data-type="window">Window</button>
        <button data-type="door">Door</button>
        <button data-type="stairs">Stairs</button>
        <button data-type="torch">Torch</button>
        <button data-type="lantern">Lantern</button>
        <!-- Control buttons -->
        <button id="reset">Reset</button>
        <button id="zoomExtent">Zoom Extent</button>
        <!-- Zoom slider for continuous zoom control -->
        <input id="zoomSlider" type="range" min="3" max="50" step="0.1" value="8" style="max-width: 120px;">
        <!-- Zoom in/out buttons for easy zoom control -->
        <button id="zoomIn">Zoom +</button>
        <button id="zoomOut">Zoom −</button>
        <!-- Additional feature buttons -->
        <button id="undo">Undo</button>
        <button id="save">Save</button>
        <button id="load">Load</button>
        <button id="toggleGrid">Grid</button>
        <!-- Toggle stack mode: place blocks on top of existing blocks instead of removing them -->
        <button id="stackMode">Stack</button>
        <!-- Fill mode: select two points to fill an area with the current block type -->
        <button id="fillMode">Fill</button>
        <!-- Export/import: share and restore worlds via JSON -->
        <button id="exportWorld">Export</button>
        <button id="importWorld">Import</button>
        <!-- Voice command toggle -->
        <button id="voiceCmd">Voice</button>
        <!-- Size selection buttons -->
        <button data-size="1" class="size active">1×1</button>
        <button data-size="2" class="size">2×2</button>
        <button data-size="3" class="size">3×3</button>
        <!-- Height adjustment controls -->
        <button id="heightDown">−</button>
        <span id="heightDisplay">H: 0</span>
        <button id="heightUp">＋</button>
      </div>
    </div>
    <script>
      (function () {
        'use strict';

        /*
         * AR-style voxel game implementation
         * This script runs entirely in the browser with no external dependencies.
         * It uses an HTML5 canvas in 2D mode to render a simple 3D scene of cubes.
         * The camera background attempts to show the user's camera via getUserMedia;
         * if not available, a gradient fallback is displayed.
         */

        // DOM elements
        const video = document.getElementById('camera');
        const fallbackOverlay = document.getElementById('fallback');
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const status = document.getElementById('status');
        const toolbar = document.getElementById('toolbar');
        const resetBtn = document.getElementById('reset');
        const zoomBtn = document.getElementById('zoomExtent');
    // Additional buttons for new features
    const undoBtn = document.getElementById('undo');
    const saveBtn = document.getElementById('save');
    const loadBtn = document.getElementById('load');
    const gridBtn = document.getElementById('toggleGrid');
    // Zoom in/out buttons
    const zoomInBtn = document.getElementById('zoomIn');
    const zoomOutBtn = document.getElementById('zoomOut');
    // Stack mode toggle
    const stackModeBtn = document.getElementById('stackMode');
    // Enable stack mode by default so tapping on existing blocks adds new blocks
    // rather than removing them. Users can toggle this button to switch to
    // removal mode if needed.
    let stackMode = true;

    // Fill mode: when enabled, the user selects two corners on the ground to
    // define a rectangular area to fill with the current block type. The
    // selection state is stored in fillFirst. Use the Fill button to toggle this.
    const fillModeBtn = document.getElementById('fillMode');
    let fillMode = false;
    let fillFirst = null;

    // Export and import buttons for sharing worlds
    const exportBtn = document.getElementById('exportWorld');
    const importBtn = document.getElementById('importWorld');

    // Voice command toggle and speech recognition state
    const voiceBtn = document.getElementById('voiceCmd');
    let voiceActive = false;
    let recognition = null;

    // Zoom slider and orientation ball
    const zoomSlider = document.getElementById('zoomSlider');
    const orientBall = document.getElementById('orientBall');
    const orientCtx = orientBall.getContext('2d');
    // Zoom control ball for adjusting camera distance.  This is a separate
    // canvas element positioned below the orientation ball.  It shares a
    // similar look but the red dot moves horizontally to represent zoom.
    const zoomBall = document.getElementById('zoomBall');
    const zoomCtx = zoomBall.getContext('2d');
    const tiltSlider = document.getElementById('tiltSlider');

    // When the tilt slider value changes, update the camera's pitch (vertical rotation).
    // The slider's range is specified in degrees; convert to radians for internal use.
    if (tiltSlider) {
      tiltSlider.addEventListener('input', () => {
        const deg = parseFloat(tiltSlider.value);
        if (!isNaN(deg)) {
          // Convert degrees to radians
          const rad = deg * Math.PI / 180;
          // Clamp pitch to just under ±90° to avoid flipping
          const limit = Math.PI / 2 - 0.01;
          pitch = Math.max(-limit, Math.min(limit, rad));
        }
      });
    }

    // State for orientation ball dragging. When true, dragging on the orientation
    // ball updates the yaw and pitch directly, allowing the user to quickly
    // change the view. See event handlers below.
    let isOrientDragging = false;
    // Height adjustment controls
    const heightDownBtn = document.getElementById('heightDown');
    const heightUpBtn = document.getElementById('heightUp');
    const heightDisplay = document.getElementById('heightDisplay');
    // Menu button for collapsing/expanding the toolbar on small screens
    const menuButton = document.getElementById('menuButton');

        // Elements for camera permission prompt
        const cameraPrompt = document.getElementById('cameraPrompt');
        const cameraButton = document.getElementById('cameraButton');

        // Game state
        const world = new Map(); // key -> block object {type, yawAnchor?, pitchAnchor?}
    // Track doors that have been opened (toggled to invisible). When a door is opened
    // we remove it from the world map and store it here so it can be restored
    // on a subsequent tap. Keys are of the form "x,y,z".
    const openDoors = new Map();
        let currentType = 'grass';
        let placeSize = 1; // size of placement (1×1, 2×2, 3×3)
    // History of actions for undo functionality
    let history = [];
    // Whether to draw grid lines on the ground plane
    let showGrid = false;
    // Preview cell for ghost block placement
    let previewCell = null;

    // Height offset for placement on ground plane. Allows building at different Y levels.
    let heightOffset = 0;

    // Store midpoint and lookAt for panning (two-finger drag)
    let startMidPoint = null;
    let startLookAt = null;
        // Base orientation anchor thresholds (radians). Blocks with anchors will only render
        // if the current camera orientation is within these thresholds of the orientation
        // when they were placed. These base values are used to derive dynamic thresholds
        // based on the camera's zoom level (camDist). See the render() function for
        // details on how these values are adjusted.
        const yawAnchorThreshold = Math.PI / 9;   // ~20 degrees
        const pitchAnchorThreshold = Math.PI / 6; // ~30 degrees
        // Base translation threshold (in world units). Blocks will only render
        // if the current camera position is within this distance of the position
        // where the block was created. Dynamic thresholds based on camDist will
        // expand this range when zoomed out.
        const posAnchorThreshold = 4;

        // Flag to track whether the camera has been initialized. The camera API often
        // requires a user gesture to start on mobile devices, so we call initCamera()
        // on the first user interaction if it hasn't already been started successfully.
        let cameraInitialized = false;

        // Helper functions for camera permission prompt
        function showCameraPrompt() {
          cameraPrompt.style.display = 'flex';
        }
        function hideCameraPrompt() {
          cameraPrompt.style.display = 'none';
        }

        // Compute the absolute difference between two angles, wrapping around 2π.
        function angleDifference(a, b) {
          let diff = Math.abs(a - b) % (2 * Math.PI);
          return diff > Math.PI ? 2 * Math.PI - diff : diff;
        }
        const blockTypes = {
          grass: { color: { r: 95, g: 159, b: 53 } }, // greenish
          stone: { color: { r: 120, g: 120, b: 120 } }, // grey
          glass: { color: { r: 180, g: 220, b: 255 }, transparent: true }, // light blue semi-transparent
          wood: { color: { r: 153, g: 101, b: 21 } }, // brown wood
          brick: { color: { r: 181, g: 58, b: 40 } }, // reddish brick
          road: { color: { r: 60, g: 60, b: 60 } }, // dark grey road
        sand: { color: { r: 194, g: 178, b: 128 } }, // light yellow sand
        water: { color: { r: 64, g: 164, b: 223 }, transparent: true }, // blue semi-transparent water
        roof: { color: { r: 165, g: 42, b: 42 } }, // reddish-brown roof
        // New block types for richer variety
        window: { color: { r: 200, g: 230, b: 250 }, transparent: true },
        door: { color: { r: 150, g: 75, b: 0 }, interactive: true },
        stairs: { color: { r: 170, g: 120, b: 75 } },
        torch: { color: { r: 255, g: 200, b: 50 } },
        lantern: { color: { r: 255, g: 150, b: 0 } },
        };

        // Camera parameters
        let yaw = Math.PI / 4; // horizontal rotation
        let pitch = -Math.PI / 6; // vertical rotation
        let camDist = 8; // distance from lookAt point
        const lookAt = { x: 0, y: 0.5, z: 0 }; // center of world (slightly raised)
        const fov = Math.PI / 3; // 60 degrees field of view

        // Interaction state
        let isDragging = false;
        let pointerId = null;
        let startX = 0;
        let startY = 0;
        let startYaw = 0;
        let startPitch = 0;
        let pinchStartDist = 0;
        let startCamDist = camDist;
        let pointerPositions = {}; // track multiple pointers for pinch

        // Precomputed faces for picking
        let lastFaces = [];

        // Set up UI event handlers
        toolbar.addEventListener('click', (e) => {
          const btn = e.target;
          if (btn.tagName === 'BUTTON') {
            const type = btn.getAttribute('data-type');
            const sizeAttr = btn.getAttribute('data-size');
            if (type) {
              currentType = type;
              // Highlight selected block type; remove active from all type buttons
              Array.from(toolbar.querySelectorAll('button[data-type]')).forEach((b) => b.classList.remove('active'));
              btn.classList.add('active');
            } else if (sizeAttr) {
              // Update placement size
              const newSize = parseInt(sizeAttr, 10);
              if (!isNaN(newSize)) {
                placeSize = newSize;
                // Highlight selected size
                Array.from(toolbar.querySelectorAll('button[data-size]')).forEach((b) => b.classList.remove('active'));
                btn.classList.add('active');
              }
            }
          }
        });

        resetBtn.addEventListener('click', () => {
          world.clear();
          openDoors.clear();
          fillFirst = null;
          // Reinitialize ground plane after clearing. Use the larger size (15)
          // so that the ground remains large enough for complex structures.
          initGround(15);
      // Clear history on reset
      history = [];
        });

        // Zoom to fit all voxels in view
        zoomBtn.addEventListener('click', () => {
          zoomToExtent();
        });

    // Discrete zoom controls for improved mobile usability
    zoomInBtn.addEventListener('click', () => {
      // Reduce camera distance by 20% but clamp to minimum to avoid flipping
      camDist = Math.max(3, camDist * 0.8);
    });
    zoomOutBtn.addEventListener('click', () => {
      // Increase camera distance by 25% but clamp to avoid excessive zoom out
      camDist = Math.min(50, camDist * 1.25);
    });

    // Continuous zoom slider control
    zoomSlider.addEventListener('input', () => {
      const val = parseFloat(zoomSlider.value);
      if (!isNaN(val)) {
        camDist = Math.max(3, Math.min(50, val));
      }
    });

    // Toggle stack mode: when enabled, tapping on an existing block will place a new block on
    // the face you tapped instead of removing it. The button highlights when active.
    stackModeBtn.addEventListener('click', () => {
      stackMode = !stackMode;
      stackModeBtn.classList.toggle('active', stackMode);
    });

    // Since stackMode starts enabled, reflect this in the UI by adding the active class.
    stackModeBtn.classList.add('active');

    // Toggle Fill mode
    fillModeBtn.addEventListener('click', () => {
      fillMode = !fillMode;
      fillModeBtn.classList.toggle('active', fillMode);
      // Reset first selection when toggling
      fillFirst = null;
      status.textContent = fillMode ? 'Fill mode: tap first corner' : '';
    });

    // Export world data to JSON
    exportBtn.addEventListener('click', () => {
      const data = {
        world: Array.from(world.entries()),
        openDoors: Array.from(openDoors.entries()),
      };
      const json = JSON.stringify(data);
      try {
        if (navigator.clipboard && navigator.clipboard.writeText) {
          navigator.clipboard.writeText(json).then(() => {
            status.textContent = 'World exported to clipboard';
          });
        } else {
          // Fallback: use prompt for user to copy manually
          window.prompt('Copy world data:', json);
          status.textContent = 'World export ready';
        }
      } catch (e) {
        window.prompt('Copy world data:', json);
        status.textContent = 'World export ready';
      }
    });

    // Import world data from JSON
    importBtn.addEventListener('click', () => {
      const json = window.prompt('Paste world data:');
      if (!json) return;
      try {
        const data = JSON.parse(json);
        world.clear();
        openDoors.clear();
        fillFirst = null;
        // Reinitialize ground
        initGround(15);
        if (data.world && Array.isArray(data.world)) {
          data.world.forEach(([key, blk]) => {
            world.set(key, blk);
          });
        }
        if (data.openDoors && Array.isArray(data.openDoors)) {
          data.openDoors.forEach(([key, blk]) => {
            openDoors.set(key, blk);
          });
        }
        // Recalculate camera distance and update slider
        zoomToExtent();
        if (zoomSlider) zoomSlider.value = String(camDist);
        status.textContent = 'World imported';
      } catch (e) {
        alert('Invalid world data');
      }
    });

    // Voice command button toggles speech recognition
    voiceBtn.addEventListener('click', () => {
      if (voiceActive) {
        // Stop recognition if active
        if (recognition) recognition.stop();
        voiceActive = false;
        voiceBtn.classList.remove('active');
        status.textContent = 'Voice deactivated';
        return;
      }
      // Initialize speech recognition if supported
      const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
      if (!SpeechRecognition) {
        status.textContent = 'Voice commands unsupported in this browser';
        return;
      }
      recognition = new SpeechRecognition();
      recognition.lang = 'en-US';
      recognition.continuous = false;
      recognition.interimResults = false;
      voiceActive = true;
      voiceBtn.classList.add('active');
      status.textContent = 'Listening...';
      recognition.onresult = (event) => {
        if (!event.results || event.results.length === 0) return;
        const transcript = event.results[0][0].transcript.toLowerCase();
        status.textContent = `Heard: ${transcript}`;
        // Recognize block type commands
        Object.keys(blockTypes).forEach((bt) => {
          if (transcript.includes(bt)) {
            currentType = bt;
            // Highlight selected block type in toolbar
            Array.from(toolbar.querySelectorAll('button[data-type]')).forEach((b) => b.classList.remove('active'));
            const btn = toolbar.querySelector(`button[data-type="${bt}"]`);
            if (btn) btn.classList.add('active');
          }
        });
        // Recognize stack mode toggle
        if (transcript.includes('stack')) {
          stackMode = !stackMode;
          stackModeBtn.classList.toggle('active', stackMode);
        }
        // Recognize fill toggle
        if (transcript.includes('fill')) {
          fillMode = !fillMode;
          fillModeBtn.classList.toggle('active', fillMode);
          fillFirst = null;
        }
        // Recognize undo command
        if (transcript.includes('undo')) {
          undoBtn.click();
        }
        // Recognize save/load commands
        if (transcript.includes('save')) {
          saveBtn.click();
        }
        if (transcript.includes('load')) {
          loadBtn.click();
        }
        // Recognize zoom commands
        if (transcript.includes('zoom in')) {
          zoomInBtn.click();
        }
        if (transcript.includes('zoom out')) {
          zoomOutBtn.click();
        }
        if (transcript.includes('reset')) {
          resetBtn.click();
        }
        // Stop recognition after processing
        voiceActive = false;
        voiceBtn.classList.remove('active');
        recognition.stop();
      };
      recognition.onerror = () => {
        voiceActive = false;
        voiceBtn.classList.remove('active');
        status.textContent = 'Voice error';
      };
      recognition.onend = () => {
        if (voiceActive) {
          // automatically restart
          recognition.start();
        }
      };
      recognition.start();
    });

    // Orientation ball interaction: allows the user to rotate the camera by dragging
    // on the orientation ball. Converts the 2D pointer position on the ball into
    // yaw and pitch angles. This overrides the default drag-to-rotate gesture when
    // interacting with the orientation ball, preventing interference with canvas
    // pointer events.
    function updateOrientationFromEvent(e) {
      // Do not allow default behavior
      e.preventDefault();
      // Compute local coordinates within the ball
      const rect = orientBall.getBoundingClientRect();
      const cx = rect.width / 2;
      const cy = rect.height / 2;
      const x = e.clientX - rect.left - cx;
      const y = e.clientY - rect.top - cy;
      // Determine radius (subtract margin) and normalize coordinates
      const radius = Math.min(rect.width, rect.height) / 2 - 4;
      let dx = x / radius;
      let dy = y / radius;
      // If pointer is outside the sphere, project onto the sphere surface
      const dist2 = dx * dx + dy * dy;
      if (dist2 > 1) {
        const dist = Math.sqrt(dist2);
        dx /= dist;
        dy /= dist;
      }
      // Invert Y to match pitch direction (upwards motion increases pitch)
      const dirY = -dy;
      const dirX = dx;
      // Compute dirZ on the unit sphere
      const temp = 1 - dirX * dirX - dirY * dirY;
      const dirZ = temp > 0 ? Math.sqrt(temp) : 0;
      // Update yaw only.  The zoom ball is responsible for adjusting pitch (tilt).
      yaw = Math.atan2(dirX, dirZ);
      // Do not update pitch here; it will be modified by updateZoomFromEvent when the user
      // drags on the zoom ball.  This separation keeps the two balls independent.
    }
    orientBall.addEventListener('pointerdown', (e) => {
      e.stopPropagation();
      isOrientDragging = true;
      updateOrientationFromEvent(e);
    });
    orientBall.addEventListener('pointermove', (e) => {
      if (isOrientDragging) {
        e.stopPropagation();
        updateOrientationFromEvent(e);
      }
    });
    orientBall.addEventListener('pointerup', (e) => {
      if (isOrientDragging) {
        isOrientDragging = false;
        e.stopPropagation();
      }
    });
    orientBall.addEventListener('pointerleave', (e) => {
      if (isOrientDragging) {
        isOrientDragging = false;
        e.stopPropagation();
      }
    });

    // Zoom ball interaction: allows the user to adjust the camera distance by
    // dragging horizontally across the zoom ball. The horizontal position of
    // the pointer relative to the center of the ball maps to a zoom ratio
    // between the minimum and maximum distances. This does not affect
    // camera orientation—orientation is controlled solely by the orientation ball.
    let isZoomDragging = false;
    function updateZoomFromEvent(e) {
      e.preventDefault();
      const rect = zoomBall.getBoundingClientRect();
      const cx = rect.width / 2;
      // Determine radius (subtract margin) for mapping
      const radius = Math.min(rect.width, rect.height) / 2 - 4;
      // Compute horizontal offset from center
      const localX = e.clientX - rect.left - cx;
      // Normalize horizontal offset to [-1,1]
      let dx = localX / radius;
      if (dx < -1) dx = -1;
      if (dx > 1) dx = 1;
      // Map normalized value to [0,1] ratio
      let ratio = (dx + 1) / 2;
      ratio = Math.max(0, Math.min(1, ratio));
      const minDist = parseFloat(zoomSlider.min);
      const maxDist = parseFloat(zoomSlider.max);
      camDist = minDist + ratio * (maxDist - minDist);
      // Sync slider with camDist
      zoomSlider.value = String(camDist);
    }
    zoomBall.addEventListener('pointerdown', (e) => {
      e.stopPropagation();
      isZoomDragging = true;
      updateZoomFromEvent(e);
    });
    zoomBall.addEventListener('pointermove', (e) => {
      if (isZoomDragging) {
        e.stopPropagation();
        updateZoomFromEvent(e);
      }
    });
    zoomBall.addEventListener('pointerup', (e) => {
      if (isZoomDragging) {
        isZoomDragging = false;
        e.stopPropagation();
      }
    });
    zoomBall.addEventListener('pointerleave', (e) => {
      if (isZoomDragging) {
        isZoomDragging = false;
        e.stopPropagation();
      }
    });

    // Undo last action
    undoBtn.addEventListener('click', () => {
      undoLastAction();
    });

    // Save the current world to localStorage
    saveBtn.addEventListener('click', () => {
      saveWorld();
    });

    // Load the world from localStorage
    loadBtn.addEventListener('click', () => {
      loadWorld();
    });

    // Toggle grid visibility
    gridBtn.addEventListener('click', () => {
      showGrid = !showGrid;
      gridBtn.classList.toggle('active', showGrid);
    });

    // Collapse/expand toolbar when the mobile menu button is clicked
    menuButton.addEventListener('click', () => {
      toolbar.classList.toggle('expanded');
      // Start camera on menu interaction if it hasn't been initialized yet
      if (!cameraInitialized) {
        initCamera();
      }
    });

    // Handle camera enable button in the camera prompt
    cameraButton.addEventListener('click', () => {
      // Hide the prompt immediately to reveal the game area while requesting camera
      hideCameraPrompt();
      if (!cameraInitialized) {
        initCamera();
      }
    });

    // Adjust height offset for placement on ground plane
    function updateHeightDisplay() {
      heightDisplay.textContent = `H: ${heightOffset}`;
    }

    // Draw the orientation ball indicator. This visualizes the current yaw and pitch
    // angles on a small sphere. A red dot represents the camera's direction: left/right
    // corresponds to yaw and up/down corresponds to pitch. The sphere is rendered with
    // simple radial shading for better visibility.
    function drawOrientationBall() {
      const ctx2 = orientCtx;
      const w = orientBall.width;
      const h = orientBall.height;
      const cx = w / 2;
      const cy = h / 2;
      const radius = Math.min(w, h) / 2 - 4;
      // Clear previous drawing
      ctx2.clearRect(0, 0, w, h);
      // Draw shaded sphere
      const grad = ctx2.createRadialGradient(cx - radius / 3, cy - radius / 3, radius * 0.2, cx, cy, radius);
      grad.addColorStop(0, '#dddddd');
      grad.addColorStop(1, '#666666');
      ctx2.fillStyle = grad;
      ctx2.beginPath();
      ctx2.arc(cx, cy, radius, 0, Math.PI * 2);
      ctx2.fill();
      // Draw cross lines to indicate axes
      ctx2.strokeStyle = 'rgba(255,255,255,0.4)';
      ctx2.lineWidth = 1;
      ctx2.beginPath();
      ctx2.moveTo(cx - radius, cy);
      ctx2.lineTo(cx + radius, cy);
      ctx2.moveTo(cx, cy - radius);
      ctx2.lineTo(cx, cy + radius);
      ctx2.stroke();
      // Compute direction vector from yaw and pitch
      const dirX = Math.cos(pitch) * Math.sin(yaw);
      const dirY = Math.sin(pitch);
      // Map orientation to 2D coordinates on the sphere
      const px = cx + dirX * radius;
      const py = cy - dirY * radius;
      // Draw orientation dot
      ctx2.fillStyle = 'rgba(255,80,80,0.9)';
      ctx2.beginPath();
      ctx2.arc(px, py, 4, 0, Math.PI * 2);
      ctx2.fill();
    }

    // Draw the zoom ball indicator.  This visualizes the current camera distance
    // as a red dot that slides horizontally across a shaded sphere.  The dot
    // position maps the camera distance to the range [0,1], where 0
    // corresponds to the minimum zoom (closest view) and 1 corresponds to
    // the maximum zoom (farthest view).  Dragging on the ball updates
    // camDist accordingly.
    function drawZoomBall() {
      const ctx2 = zoomCtx;
      const w = zoomBall.width;
      const h = zoomBall.height;
      const cx = w / 2;
      const cy = h / 2;
      const radius = Math.min(w, h) / 2 - 4;
      // Clear previous drawing
      ctx2.clearRect(0, 0, w, h);
      // Draw shaded sphere
      const grad = ctx2.createRadialGradient(cx - radius / 3, cy - radius / 3, radius * 0.2, cx, cy, radius);
      grad.addColorStop(0, '#dddddd');
      grad.addColorStop(1, '#666666');
      ctx2.fillStyle = grad;
      ctx2.beginPath();
      ctx2.arc(cx, cy, radius, 0, Math.PI * 2);
      ctx2.fill();
      // Draw cross lines to indicate axes
      ctx2.strokeStyle = 'rgba(255,255,255,0.4)';
      ctx2.lineWidth = 1;
      ctx2.beginPath();
      // horizontal line through center
      ctx2.moveTo(cx - radius, cy);
      ctx2.lineTo(cx + radius, cy);
      // vertical line through center
      ctx2.moveTo(cx, cy - radius);
      ctx2.lineTo(cx, cy + radius);
      ctx2.stroke();
      // Compute ratio of current camera distance between min and max
      const minDist = parseFloat(zoomSlider.min);
      const maxDist = parseFloat(zoomSlider.max);
      const ratio = (camDist - minDist) / (maxDist - minDist);
      // Clamp ratio between 0 and 1
      const clamped = Math.max(0, Math.min(1, ratio));
      // Map to horizontal displacement across the ball: range [-radius, +radius]
      const pxOffset = clamped * 2 * radius - radius;
      const pxBall = cx + pxOffset;
      const pyBall = cy;
      // Draw zoom indicator dot
      ctx2.fillStyle = 'rgba(255,80,80,0.9)';
      ctx2.beginPath();
      ctx2.arc(pxBall, pyBall, 4, 0, Math.PI * 2);
      ctx2.fill();
    }
    heightUpBtn.addEventListener('click', () => {
      heightOffset = Math.min(heightOffset + 1, 10);
      updateHeightDisplay();
    });
    heightDownBtn.addEventListener('click', () => {
      heightOffset = Math.max(heightOffset - 1, -10);
      updateHeightDisplay();
    });

        // Resize canvas to fill the screen
        function resizeCanvas() {
          canvas.width = canvas.clientWidth;
          canvas.height = canvas.clientHeight;
        }
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();

        // Try to start camera for background
        async function initCamera() {
          try {
            // Prefer the back camera (environment) if available
            const stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: 'environment' } });
            video.srcObject = stream;
            await video.play();
            fallbackOverlay.style.display = 'none';
            cameraInitialized = true;
            // Hide the camera prompt on success
            hideCameraPrompt();
          } catch (err) {
            console.warn('Environment camera unavailable or denied, trying default camera.', err);
            try {
              // Fall back to any available camera
              const stream = await navigator.mediaDevices.getUserMedia({ video: true });
              video.srcObject = stream;
              await video.play();
              fallbackOverlay.style.display = 'none';
              cameraInitialized = true;
              // Hide the camera prompt on success
              hideCameraPrompt();
            } catch (err2) {
              // All camera requests failed or permission denied
              fallbackOverlay.style.display = 'block';
              console.warn('Camera unavailable:', err2);
              // Notify the user via the status bar instead of blocking with a prompt
              status.textContent = 'Camera unavailable or permission denied. Using fallback background.';
              // Hide the camera prompt so the game area remains interactive
              hideCameraPrompt();
            }
          }
        }
        // Do not automatically start the camera on load. Many mobile browsers require
        // a user gesture (e.g., a tap) to grant camera access. Instead, we call
        // initCamera() on the first user interaction (pointerdown or menu click).

        // Helper: compute camera position from yaw/pitch/distance
        function getCameraPos() {
          const x = lookAt.x + camDist * Math.cos(pitch) * Math.sin(yaw);
          const y = lookAt.y + camDist * Math.sin(pitch);
          const z = lookAt.z + camDist * Math.cos(pitch) * Math.cos(yaw);
          return { x, y, z };
        }

        // Helper: transform world coordinates to camera space
        function worldToCamera(pt, camPos) {
          // Translate relative to camera
          let dx = pt.x - camPos.x;
          let dy = pt.y - camPos.y;
          let dz = pt.z - camPos.z;
          // Apply inverse yaw rotation (rotate around Y)
          const cosy = Math.cos(-yaw);
          const siny = Math.sin(-yaw);
          let x1 = cosy * dx - siny * dz;
          let z1 = siny * dx + cosy * dz;
          let y1 = dy;
          // Apply inverse pitch rotation (rotate around X)
          const cosp = Math.cos(-pitch);
          const sinp = Math.sin(-pitch);
          let y2 = cosp * y1 - sinp * z1;
          let z2 = sinp * y1 + cosp * z1;
          return { x: x1, y: y2, z: z2 };
        }

        // Helper: convert camera space to screen space
        function cameraToScreen(pt, width, height) {
          // Perspective projection: note that z should be positive in front of camera
          const aspect = width / height;
          const f = 1 / Math.tan(fov / 2);
          const ndcX = (pt.x * f) / (pt.z * aspect);
          const ndcY = (pt.y * f) / pt.z;
          const screenX = (ndcX + 1) * 0.5 * width;
          const screenY = (1 - (ndcY + 1) * 0.5) * height;
          return { x: screenX, y: screenY };
        }

        // Helper: compute vector dot product
        function dot(a, b) {
          return a.x * b.x + a.y * b.y + a.z * b.z;
        }

        // Rendering loop
        let lastTime = performance.now();
        let frameCount = 0;
        let fps = 0;
        function render() {
          requestAnimationFrame(render);
          // FPS calculation
          const now = performance.now();
          frameCount++;
          if (now - lastTime > 1000) {
            fps = frameCount;
            frameCount = 0;
            lastTime = now;
          }
          const { width, height } = canvas;
          ctx.clearRect(0, 0, width, height);
          const camPos = getCameraPos();

          // Dynamically adjust anchor thresholds based on the current camera distance.  The farther
          // the camera is from the scene (larger camDist), the more lenient the thresholds become.
          // This allows the user to reveal anchored blocks by zooming out.  When zoomed in,
          // thresholds are tight so that only blocks anchored close to the current view and position
          // are shown.
          let dynamicYawAnchor = yawAnchorThreshold;
          let dynamicPitchAnchor = pitchAnchorThreshold;
          let dynamicPosAnchor = posAnchorThreshold;
          if (zoomSlider) {
            const minDist = parseFloat(zoomSlider.min);
            const maxDist = parseFloat(zoomSlider.max);
            const ratio = (camDist - minDist) / (maxDist - minDist);
            const clampedRatio = Math.max(0, Math.min(1, ratio));
            // Increase thresholds linearly with zoom ratio.  At maximum zoom, thresholds
            // double (orientation) and triple (position) from their base values.  At minimum
            // zoom, thresholds remain at the base values.
            dynamicYawAnchor = yawAnchorThreshold * (1 + clampedRatio);
            dynamicPitchAnchor = pitchAnchorThreshold * (1 + clampedRatio);
            dynamicPosAnchor = posAnchorThreshold * (1 + clampedRatio * 2);
          }

          // Precompute light direction in camera space
          const lightDirWorld = { x: -0.5, y: 1, z: -0.5 };
          // Normalize light direction
          const mag = Math.hypot(lightDirWorld.x, lightDirWorld.y, lightDirWorld.z);
          const lightDir = {
            x: lightDirWorld.x / mag,
            y: lightDirWorld.y / mag,
            z: lightDirWorld.z / mag,
          };
          // Rotate light direction into camera space (inverse yaw and pitch)
          const ldCam = worldToCamera(
            { x: camPos.x + lightDir.x, y: camPos.y + lightDir.y, z: camPos.z + lightDir.z },
            camPos
          );
          const ldCamMag = Math.hypot(ldCam.x, ldCam.y, ldCam.z);
          const lightCamDir = { x: ldCam.x / ldCamMag, y: ldCam.y / ldCamMag, z: ldCam.z / ldCamMag };

          // Collect visible faces
          const faces = [];
          // Iterate over world blocks
          world.forEach((block, key) => {
            // Determine block type and orientation anchors (if any)
            let typeName;
            let anchorYaw;
            let anchorPitch;
            let anchorX;
            let anchorZ;
            if (typeof block === 'object') {
              typeName = block.type;
              anchorYaw = block.yawAnchor;
              anchorPitch = block.pitchAnchor;
              anchorX = block.posAnchorX;
              anchorZ = block.posAnchorZ;
            } else {
              typeName = block;
            }
            // If the block has orientation and position anchors, only render it when the
            // current camera orientation and position are within the defined thresholds.
            // This simulates spatial anchoring: blocks remain fixed in world coordinates
            // but are only visible when you return to the same direction and location.
            if (anchorYaw !== undefined) {
              const yawDiff = angleDifference(yaw, anchorYaw);
              const pitchDiff = angleDifference(pitch, anchorPitch);
              const posDiff = Math.hypot(camPos.x - anchorX, camPos.z - anchorZ);
              // Use dynamic thresholds computed at the start of the render loop.  When zoomed
              // out, these thresholds increase, allowing more anchored blocks to remain
              // visible.  When zoomed in, the thresholds shrink back to their base values.
              if (
                yawDiff > dynamicYawAnchor ||
                pitchDiff > dynamicPitchAnchor ||
                posDiff > dynamicPosAnchor
              ) {
                // Skip rendering this block if outside thresholds
                return;
              }
            }
            const [bx, by, bz] = key.split(',').map(Number);
            // Define cube vertices relative to block center at (bx,by,bz)
            const verts = [
              { x: bx - 0.5, y: by - 0.5, z: bz - 0.5 },
              { x: bx + 0.5, y: by - 0.5, z: bz - 0.5 },
              { x: bx + 0.5, y: by + 0.5, z: bz - 0.5 },
              { x: bx - 0.5, y: by + 0.5, z: bz - 0.5 },
              { x: bx - 0.5, y: by - 0.5, z: bz + 0.5 },
              { x: bx + 0.5, y: by - 0.5, z: bz + 0.5 },
              { x: bx + 0.5, y: by + 0.5, z: bz + 0.5 },
              { x: bx - 0.5, y: by + 0.5, z: bz + 0.5 },
            ];
            // Face definitions: [vertex indices], normal vector in world space
            const cubeFaces = [
              { idx: [0, 1, 2, 3], normal: { x: 0, y: 0, z: -1 } }, // back
              { idx: [4, 5, 6, 7], normal: { x: 0, y: 0, z: 1 } }, // front
              { idx: [0, 1, 5, 4], normal: { x: 0, y: -1, z: 0 } }, // bottom
              { idx: [3, 2, 6, 7], normal: { x: 0, y: 1, z: 0 } }, // top
              { idx: [1, 2, 6, 5], normal: { x: 1, y: 0, z: 0 } }, // right
              { idx: [0, 3, 7, 4], normal: { x: -1, y: 0, z: 0 } }, // left
            ];
            // Transform vertices to camera space and skip cube if all vertices behind camera
            const camVerts = verts.map((v) => worldToCamera(v, camPos));
            // Determine if cube is visible (any vertex has z > 0)
            if (!camVerts.some((v) => v.z > 0)) return;
            cubeFaces.forEach((face) => {
              // Determine if face is visible: normal pointing towards camera in camera space
              // Transform normal to camera space (approx by rotating point on face center slightly offset by normal)
              const worldCenter = {
                x: bx + face.normal.x * 0.5,
                y: by + face.normal.y * 0.5,
                z: bz + face.normal.z * 0.5,
              };
              const camCenter = worldToCamera(worldCenter, camPos);
              // If face center behind camera, skip
              if (camCenter.z <= 0) return;
              // Compute face normal in camera space by subtracting camera-space block center and camera-space adjacent point
              // For shading dot product (approx) we use world normal rotated into camera space by same rotations
              // Here we convert world normal directly into camera space using yaw & pitch inverse
              const nCam = worldToCamera(
                {
                  x: camPos.x + face.normal.x,
                  y: camPos.y + face.normal.y,
                  z: camPos.z + face.normal.z,
                },
                camPos
              );
              const nLen = Math.hypot(nCam.x, nCam.y, nCam.z);
              const normalCam = { x: nCam.x / nLen, y: nCam.y / nLen, z: nCam.z / nLen };
              // Check if face normal is facing camera (dot with camera forward axis 0,0,1 in camera space negative)
              if (normalCam.z >= 0) return; // face turned away
              // Project vertices to screen
              const pts = face.idx.map((i) => {
                const p = camVerts[i];
                return cameraToScreen(p, width, height);
              });
              // Compute depth for painter's algorithm (average z)
              const depth = face.idx.reduce((acc, i) => acc + camVerts[i].z, 0) / 4;
              // Lighting: dot between face normal (world) and light direction (camera space)
              const lightDot = Math.max(0, -dot(normalCam, lightCamDir));
              // Determine color (with slight brightness)
              const baseColor = blockTypes[typeName].color;
              const brightness = 0.3 + 0.7 * lightDot;
              const r = Math.round(baseColor.r * brightness);
              const g = Math.round(baseColor.g * brightness);
              const b = Math.round(baseColor.b * brightness);
              // Determine alpha for semi-transparent blocks (glass)
              const alpha = blockTypes[typeName].transparent ? 0.5 : 1;
              faces.push({
                pts,
                depth,
                color: `rgba(${r},${g},${b},${alpha})`,
                blockKey: key,
                normal: face.normal,
              });
            });
          });
          // Sort faces by depth (far to near)
          faces.sort((a, b) => b.depth - a.depth);
          lastFaces = faces;
          // Draw faces
          faces.forEach((f) => {
            ctx.beginPath();
            ctx.moveTo(f.pts[0].x, f.pts[0].y);
            for (let i = 1; i < f.pts.length; i++) {
              ctx.lineTo(f.pts[i].x, f.pts[i].y);
            }
            ctx.closePath();
            ctx.fillStyle = f.color;
            ctx.fill();
            ctx.strokeStyle = 'rgba(0,0,0,0.2)';
            ctx.lineWidth = 1;
            ctx.stroke();
          });
          // Optionally draw grid lines on ground plane
          if (showGrid) {
            ctx.strokeStyle = 'rgba(255,255,255,0.1)';
            ctx.lineWidth = 1;
            world.forEach((block, key) => {
              const [gx, gy, gz] = key.split(',').map(Number);
              if (gy !== 0) return;
              // Define corner points for cell edges at y=0
              const corners = [
                { x: gx - 0.5, y: gy + 0.001, z: gz - 0.5 },
                { x: gx + 0.5, y: gy + 0.001, z: gz - 0.5 },
                { x: gx + 0.5, y: gy + 0.001, z: gz + 0.5 },
                { x: gx - 0.5, y: gy + 0.001, z: gz + 0.5 },
              ];
              // Transform to camera space and ensure some part is visible
              const camCorners = corners.map((c) => worldToCamera(c, camPos));
              if (!camCorners.some((v) => v.z > 0)) return;
              // Project to screen
              const ptsGrid = camCorners.map((p) => cameraToScreen(p, width, height));
              // Draw edges
              ctx.beginPath();
              ctx.moveTo(ptsGrid[0].x, ptsGrid[0].y);
              for (let i = 1; i < ptsGrid.length; i++) {
                ctx.lineTo(ptsGrid[i].x, ptsGrid[i].y);
              }
              ctx.closePath();
              ctx.stroke();
            });
          }
          // Draw preview ghost block if available
          if (previewCell) {
            const baseX = previewCell.x;
            const baseY = previewCell.y;
            const baseZ = previewCell.z;
            const facesPrev = [];
            // Iterate over group cells for preview
            for (let dx = 0; dx < placeSize; dx++) {
              for (let dz = 0; dz < placeSize; dz++) {
                const bx = baseX + dx;
                const by = baseY;
                const bz = baseZ + dz;
                // Define cube vertices for preview cell
                const vertsPrev = [
                  { x: bx - 0.5, y: by - 0.5, z: bz - 0.5 },
                  { x: bx + 0.5, y: by - 0.5, z: bz - 0.5 },
                  { x: bx + 0.5, y: by + 0.5, z: bz - 0.5 },
                  { x: bx - 0.5, y: by + 0.5, z: bz - 0.5 },
                  { x: bx - 0.5, y: by - 0.5, z: bz + 0.5 },
                  { x: bx + 0.5, y: by - 0.5, z: bz + 0.5 },
                  { x: bx + 0.5, y: by + 0.5, z: bz + 0.5 },
                  { x: bx - 0.5, y: by + 0.5, z: bz + 0.5 },
                ];
                const camVertsPrev = vertsPrev.map((v) => worldToCamera(v, camPos));
                // Skip if cube is entirely behind camera
                if (!camVertsPrev.some((v) => v.z > 0)) continue;
                const cubeFacesPrev = [
                  { idx: [0, 1, 2, 3], normal: { x: 0, y: 0, z: -1 } },
                  { idx: [4, 5, 6, 7], normal: { x: 0, y: 0, z: 1 } },
                  { idx: [0, 1, 5, 4], normal: { x: 0, y: -1, z: 0 } },
                  { idx: [3, 2, 6, 7], normal: { x: 0, y: 1, z: 0 } },
                  { idx: [1, 2, 6, 5], normal: { x: 1, y: 0, z: 0 } },
                  { idx: [0, 3, 7, 4], normal: { x: -1, y: 0, z: 0 } },
                ];
                cubeFacesPrev.forEach((face) => {
                  const worldCenter = {
                    x: bx + face.normal.x * 0.5,
                    y: by + face.normal.y * 0.5,
                    z: bz + face.normal.z * 0.5,
                  };
                  const camCenter = worldToCamera(worldCenter, camPos);
                  if (camCenter.z <= 0) return;
                  const nCam = worldToCamera(
                    { x: camPos.x + face.normal.x, y: camPos.y + face.normal.y, z: camPos.z + face.normal.z },
                    camPos
                  );
                  const nLen = Math.hypot(nCam.x, nCam.y, nCam.z);
                  const normalCam = { x: nCam.x / nLen, y: nCam.y / nLen, z: nCam.z / nLen };
                  if (normalCam.z >= 0) return;
                  const ptsPrev = face.idx.map((i) => cameraToScreen(camVertsPrev[i], width, height));
                  const depthPrev = face.idx.reduce((acc, i) => acc + camVertsPrev[i].z, 0) / 4;
                  const baseC = blockTypes[currentType].color;
                  const brightnessPrev = 0.5;
                  const rP = Math.round(baseC.r * brightnessPrev);
                  const gP = Math.round(baseC.g * brightnessPrev);
                  const bP = Math.round(baseC.b * brightnessPrev);
                  facesPrev.push({ pts: ptsPrev, depth: depthPrev, color: `rgba(${rP},${gP},${bP},0.3)` });
                });
              }
            }
            facesPrev.sort((a, b) => b.depth - a.depth);
            facesPrev.forEach((f2) => {
              ctx.beginPath();
              ctx.moveTo(f2.pts[0].x, f2.pts[0].y);
              for (let i = 1; i < f2.pts.length; i++) {
                ctx.lineTo(f2.pts[i].x, f2.pts[i].y);
              }
              ctx.closePath();
              ctx.fillStyle = f2.color;
              ctx.fill();
            });
          }
          // Draw FPS/status
          status.textContent = `FPS: ${fps} | Blocks: ${world.size}`;

          // Keep the zoom slider in sync with the current camera distance
          if (zoomSlider) {
            zoomSlider.value = String(camDist);
          }
          // Render the orientation ball for visual feedback of yaw and pitch
          drawOrientationBall();
          // Render the zoom ball to visualize current zoom level and allow drag control
          drawZoomBall();
        }
        requestAnimationFrame(render);

        // Helper: check if point is inside polygon (simple winding algorithm)
        function pointInPolygon(px, py, pts) {
          let inside = false;
          for (let i = 0, j = pts.length - 1; i < pts.length; j = i++) {
            const xi = pts[i].x,
              yi = pts[i].y;
            const xj = pts[j].x,
              yj = pts[j].y;
            const intersect = yi > py !== yj > py && px < ((xj - xi) * (py - yi)) / (yj - yi) + xi;
            if (intersect) inside = !inside;
          }
          return inside;
        }

        // Determine highest Y at given x,z coordinate
        function highestY(x, z) {
          let max = -1;
          world.forEach((_, key) => {
            const [bx, by, bz] = key.split(',').map(Number);
            if (bx === x && bz === z) {
              const blk = world.get(key);
              // Ignore open doors when computing highest Y; they behave like empty space
              if (blk && blk.type === 'door' && blk.open) {
                return;
              }
              if (by > max) max = by;
            }
          });
          return max;
        }

        // Handle taps in Fill mode. The first tap records the start corner of a
        // rectangular region on the ground plane. The second tap computes the end
        // corner and fills the axis-aligned rectangle spanning these points with
        // blocks of the current type. Fill only operates on the ground plane
        // (y-coordinate determined by highest stack plus heightOffset) and
        // respects the selected placement size. After the fill is performed, the
        // selection is cleared but Fill mode remains active so the user can
        // perform multiple fills in sequence. To exit Fill mode, tap the Fill
        // button again.
        function handleFillTap(screenX, screenY) {
          // Convert screen coordinates to a point on the ground plane
          const grid = screenToGridPlane(screenX, screenY);
          if (!grid) return;
          const gx = Math.round(grid.x);
          const gz = Math.round(grid.z);
          if (fillFirst === null) {
            fillFirst = { x: gx, z: gz };
            // Optionally update status to indicate selection start
            status.textContent = `Fill: first corner set at (${gx}, ${gz})`;
          } else {
            // Second corner selected; fill the rectangle
            const x1 = fillFirst.x;
            const z1 = fillFirst.z;
            const x2 = gx;
            const z2 = gz;
            const minX = Math.min(x1, x2);
            const maxX = Math.max(x1, x2);
            const minZ = Math.min(z1, z2);
            const maxZ = Math.max(z1, z2);
            for (let x = minX; x <= maxX; x++) {
              for (let z = minZ; z <= maxZ; z++) {
                const h = highestY(x, z) + 1 + heightOffset;
                placeBlockGroup(x, h, z);
              }
            }
            // Add a small history marker to group this fill for undo. We push an
            // entry with type 'fill' and number of blocks equal to the area.
            history.push({ type: 'fill', area: (maxX - minX + 1) * (maxZ - minZ + 1), bounds: { x1: minX, z1: minZ, x2: maxX, z2: maxZ } });
            // Clear first corner for next selection
            fillFirst = null;
            status.textContent = 'Fill: region created';
          }
        }

        // Place blocks of the currently selected type at a base location, filling a square of
        // size (placeSize × placeSize) at the given world coordinates. Each block is anchored to the current
        // camera orientation (yaw/pitch) so that it only appears when viewing the world from a similar direction.
        function placeBlockGroup(baseX, baseY, baseZ) {
          // Keep track of newly placed blocks for undo history
          const placedKeys = [];
          // Blocks no longer store translation or orientation anchors. This retrieval is
          // preserved for potential future use but has no effect on placement.
          const camPosForAnchor = getCameraPos();
          // Record anchor position from the current camera position for spatial anchoring
          const anchorPos = getCameraPos();
          for (let dx = 0; dx < placeSize; dx++) {
            for (let dz = 0; dz < placeSize; dz++) {
              const key = `${baseX + dx},${baseY},${baseZ + dz}`;
              if (!world.has(key)) {
                // Store the block type along with orientation and position anchors.  These anchors
                // ensure the block only renders when the user returns to a similar orientation
                // (yaw/pitch) and position (x/z) as when it was placed, simulating spatial
                // anchoring in augmented reality.
                world.set(key, {
                  type: currentType,
                  yawAnchor: yaw,
                  pitchAnchor: pitch,
                  posAnchorX: anchorPos.x,
                  posAnchorZ: anchorPos.z
                });
                placedKeys.push(key);
              }
            }
          }
          // Record placement action if any blocks were added
          if (placedKeys.length > 0) {
            history.push({ type: 'place', blocks: placedKeys });
          }
        }

        // Compute world direction vector given screen coordinates
        function screenToWorldDirection(x, y) {
          const { width, height } = canvas;
          // Convert pixel to Normalized Device Coordinates [-1,1]
          const xN = (2 * x) / width - 1;
          const yN = 1 - (2 * y) / height;
          // Direction in camera space
          const aspect = width / height;
          const f = 1 / Math.tan(fov / 2);
          const dirCam = {
            x: (xN / f) * aspect,
            y: (yN / f),
            z: 1,
          };
          // Rotate into world space (inverse yaw/pitch)
          // Apply pitch rotation first
          const cosPitch = Math.cos(pitch);
          const sinPitch = Math.sin(pitch);
          let y1 = cosPitch * dirCam.y + sinPitch * dirCam.z;
          let z1 = -sinPitch * dirCam.y + cosPitch * dirCam.z;
          let x1 = dirCam.x;
          // Apply yaw rotation
          const cosYaw = Math.cos(yaw);
          const sinYaw = Math.sin(yaw);
          const x2 = cosYaw * x1 + sinYaw * z1;
          const z2 = -sinYaw * x1 + cosYaw * z1;
          const y2 = y1;
          const dirWorld = { x: x2, y: y2, z: z2 };
          // Normalize direction
          const len = Math.hypot(dirWorld.x, dirWorld.y, dirWorld.z);
          return { x: dirWorld.x / len, y: dirWorld.y / len, z: dirWorld.z / len };
        }

        // Cast ray from screen and find intersection with plane y=0 (used for placing on ground)
        function screenToGridPlane(x, y) {
          const dir = screenToWorldDirection(x, y);
          const camPos = getCameraPos();
          if (Math.abs(dir.y) < 1e-6) return null;
          const t = (0 - camPos.y) / dir.y;
          if (t <= 0) return null;
          return {
            x: camPos.x + dir.x * t,
            z: camPos.z + dir.z * t,
          };
        }

        // Compute a camera distance that fits the entire voxel world into view.
        function zoomToExtent() {
          if (world.size === 0) return;
          let minX = Infinity, minY = Infinity, minZ = Infinity;
          let maxX = -Infinity, maxY = -Infinity, maxZ = -Infinity;
          world.forEach((_, key) => {
            const [x, y, z] = key.split(',').map(Number);
            if (x < minX) minX = x;
            if (x > maxX) maxX = x;
            if (y < minY) minY = y;
            if (y > maxY) maxY = y;
            if (z < minZ) minZ = z;
            if (z > maxZ) maxZ = z;
          });
          // Compute extents (+1 to include block size)
          const extentX = maxX - minX + 1;
          const extentY = maxY - minY + 1;
          const extentZ = maxZ - minZ + 1;
          const maxExtent = Math.max(extentX, extentY, extentZ);
          // Estimate new camera distance: proportional to extent and FOV
          // tan(FOV/2) = half-height / distance => distance = half-height / tan(FOV/2)
          const half = maxExtent / 2;
          const margin = 2;
          // Use horizontal extents for width; choose conservative value using maxExtent
          camDist = half / Math.sin(fov / 2) + margin;
        }

        // Find the first empty voxel along the ray (for placing in 3D space)
        function findEmptyCellAlongRay(origin, dir, maxSteps = 100) {
          // Current cell coordinates (floor)
          let x = Math.floor(origin.x);
          let y = Math.floor(origin.y);
          let z = Math.floor(origin.z);
          // Step direction per axis
          const stepX = dir.x > 0 ? 1 : -1;
          const stepY = dir.y > 0 ? 1 : -1;
          const stepZ = dir.z > 0 ? 1 : -1;
          // Compute initial boundary distances
          const nextX = x + (stepX > 0 ? 1 : 0);
          const nextY = y + (stepY > 0 ? 1 : 0);
          const nextZ = z + (stepZ > 0 ? 1 : 0);
          let tMaxX = (dir.x !== 0) ? (nextX - origin.x) / dir.x : Infinity;
          let tMaxY = (dir.y !== 0) ? (nextY - origin.y) / dir.y : Infinity;
          let tMaxZ = (dir.z !== 0) ? (nextZ - origin.z) / dir.z : Infinity;
          const tDeltaX = (dir.x !== 0) ? Math.abs(1 / dir.x) : Infinity;
          const tDeltaY = (dir.y !== 0) ? Math.abs(1 / dir.y) : Infinity;
          const tDeltaZ = (dir.z !== 0) ? Math.abs(1 / dir.z) : Infinity;
          // Traverse voxels along ray
          for (let i = 0; i < maxSteps; i++) {
            // Step to next cell boundary before checking occupancy to skip origin cell
            if (tMaxX < tMaxY) {
              if (tMaxX < tMaxZ) {
                x += stepX;
                tMaxX += tDeltaX;
              } else {
                z += stepZ;
                tMaxZ += tDeltaZ;
              }
            } else {
              if (tMaxY < tMaxZ) {
                y += stepY;
                tMaxY += tDeltaY;
              } else {
                z += stepZ;
                tMaxZ += tDeltaZ;
              }
            }
            // After moving, check current cell for emptiness. Treat open doors as empty.
            if (y >= 0) {
              const keyStr = `${x},${y},${z}`;
              const existing = world.get(keyStr);
              const empty = !existing || (existing.type === 'door' && existing.open);
              if (empty) {
                return { x, y, z };
              }
            }
          }
          return null;
        }

        // Apply gravity to all blocks. Blocks above empty space will fall down until
        // they rest on another block or the ground (y=0). Open doors are not
        // considered blocks and therefore do not impede blocks from falling.
        function applyGravity() {
          // Group blocks by their x,z columns
          const columns = new Map();
          world.forEach((blk, key) => {
            const [bx, by, bz] = key.split(',').map(Number);
            // Skip if this key corresponds to an open door stored in openDoors
            if (openDoors.has(key)) {
              return;
            }
            const colKey = `${bx},${bz}`;
            if (!columns.has(colKey)) columns.set(colKey, []);
            columns.get(colKey).push({ y: by, key, block: blk });
          });
          // For each column, drop blocks down
          columns.forEach((cells, colKey) => {
            const [x, z] = colKey.split(',').map(Number);
            // Sort cells by ascending Y so we process from bottom to top
            cells.sort((a, b) => a.y - b.y);
            let nextY = 0;
            cells.forEach(({ y, key, block }) => {
              // If the block is below nextY, skip; else drop to nextY
              if (y !== nextY) {
                world.delete(key);
                world.set(`${x},${nextY},${z}`, block);
              }
              nextY++;
            });
          });
        }

        // Compute preview cell for ghost placement given screen coordinates
        function computePreview(screenX, screenY) {
          // Attempt to find the first empty voxel along the ray from the camera through the screen point
          const origin = getCameraPos();
          const dir = screenToWorldDirection(screenX, screenY);
          const empty = findEmptyCellAlongRay(origin, dir, 100);
          if (empty) {
            return empty;
          }
          // Fallback: intersect ray with ground plane and place block on top of the highest stack
          const grid = screenToGridPlane(screenX, screenY);
          if (!grid) return null;
          const gx = Math.round(grid.x);
          const gz = Math.round(grid.z);
          const h = highestY(gx, gz) + 1 + heightOffset;
          return { x: gx, y: h, z: gz };
        }

        // Save current world state to localStorage as JSON
        function saveWorld() {
          try {
            const data = [];
            world.forEach((block, key) => {
              data.push({ key, block });
            });
            localStorage.setItem('voxelWorld', JSON.stringify(data));
            status.textContent = 'World saved';
          } catch (err) {
            console.warn('Error saving world:', err);
          }
        }

        // Load world state from localStorage
        function loadWorld() {
          const json = localStorage.getItem('voxelWorld');
          if (!json) {
            status.textContent = 'No saved world found';
            return;
          }
          try {
            const data = JSON.parse(json);
            world.clear();
            data.forEach(({ key, block }) => {
              world.set(key, block);
            });
            status.textContent = 'World loaded';
            history = [];
          } catch (err) {
            console.warn('Error loading world:', err);
            status.textContent = 'Failed to load world';
          }
        }

        // Undo the most recent placement or removal action
        function undoLastAction() {
          const action = history.pop();
          if (!action) return;
          if (action.type === 'place') {
            // Remove placed blocks
            action.blocks.forEach((key) => {
              world.delete(key);
            });
          } else if (action.type === 'remove') {
            // Restore removed blocks
            action.blocks.forEach(({ key, block }) => {
              world.set(key, block);
            });
          }
        }

        // Pointer/gesture handlers
        canvas.addEventListener('pointerdown', (e) => {
          e.preventDefault();
          // Start the camera on first user interaction if it hasn't been initialized successfully.
          if (!cameraInitialized) {
            initCamera();
          }
          if (pointerId === null) {
            // First pointer -> rotation/drag
            pointerId = e.pointerId;
            isDragging = false;
            startX = e.clientX;
            startY = e.clientY;
            startYaw = yaw;
            startPitch = pitch;
          }
          pointerPositions[e.pointerId] = { x: e.clientX, y: e.clientY };
          if (Object.keys(pointerPositions).length === 2) {
            // Pinch start
            const ids = Object.keys(pointerPositions);
            const p1 = pointerPositions[ids[0]];
            const p2 = pointerPositions[ids[1]];
            const dx = p1.x - p2.x;
            const dy = p1.y - p2.y;
            pinchStartDist = Math.hypot(dx, dy);
            startCamDist = camDist;

            // Record midpoint and lookAt for panning
            startMidPoint = { x: (p1.x + p2.x) / 2, y: (p1.y + p2.y) / 2 };
            startLookAt = { x: lookAt.x, z: lookAt.z };
          }
        });

        canvas.addEventListener('pointermove', (e) => {
          e.preventDefault();
          if (pointerId !== null && e.pointerId === pointerId) {
            // Primary pointer
            const dx = e.clientX - startX;
            const dy = e.clientY - startY;
            if (!isDragging && Math.hypot(dx, dy) > 5) {
              isDragging = true;
            }
            if (isDragging) {
              // Update yaw/pitch for drag
              const sensitivity = 0.005;
              yaw = startYaw - dx * sensitivity;
              pitch = startPitch - dy * sensitivity;
              // Clamp pitch to avoid flipping
              const limit = Math.PI / 2 - 0.01;
              if (pitch > limit) pitch = limit;
              if (pitch < -limit) pitch = -limit;
            }
            pointerPositions[e.pointerId] = { x: e.clientX, y: e.clientY };
          }
          // Pinch gesture
          if (Object.keys(pointerPositions).length === 2) {
            const ids = Object.keys(pointerPositions);
            const p1 = pointerPositions[ids[0]];
            const p2 = pointerPositions[ids[1]];
            const dxDist = p1.x - p2.x;
            const dyDist = p1.y - p2.y;
            const dist = Math.hypot(dxDist, dyDist);
            const pinchRatio = dist / pinchStartDist;
            camDist = Math.max(3, Math.min(20, startCamDist / pinchRatio));
            // Panning: shift lookAt based on change in midpoint
            if (startMidPoint && startLookAt) {
              const curMid = { x: (p1.x + p2.x) / 2, y: (p1.y + p2.y) / 2 };
              const dxMid = curMid.x - startMidPoint.x;
              const dyMid = curMid.y - startMidPoint.y;
              // Convert pixel movement to world units based on camera distance and FOV
              const { width, height } = canvas;
              const unitsPerPixelY = (2 * camDist * Math.tan(fov / 2)) / height;
              const unitsPerPixelX = unitsPerPixelY * (width / height);
              // World right and forward (horizontal plane) directions
              const rightDir = { x: Math.cos(yaw), z: -Math.sin(yaw) };
              const forwardDir = { x: Math.sin(yaw), z: Math.cos(yaw) };
              const shiftX = (-dxMid * unitsPerPixelX) * rightDir.x + (dyMid * unitsPerPixelY) * forwardDir.x;
              const shiftZ = (-dxMid * unitsPerPixelX) * rightDir.z + (dyMid * unitsPerPixelY) * forwardDir.z;
              lookAt.x = startLookAt.x + shiftX;
              lookAt.z = startLookAt.z + shiftZ;
            }
          }

          // Update preview placement only when not dragging and a single pointer is active
          const activePointers = Object.keys(pointerPositions);
          if (!isDragging && activePointers.length === 1 && e.pointerId === pointerId) {
            const rect2 = canvas.getBoundingClientRect();
            const sx = e.clientX - rect2.left;
            const sy = e.clientY - rect2.top;
            previewCell = computePreview(sx, sy);
          } else {
            previewCell = null;
          }
        });

        canvas.addEventListener('pointerup', (e) => {
          e.preventDefault();
          delete pointerPositions[e.pointerId];
          if (e.pointerId === pointerId) {
            // Primary pointer ended
            if (!isDragging) {
              // It's a tap, handle placement/removal
              handleTap(e.clientX, e.clientY);
            }
            pointerId = null;
            isDragging = false;
          }
          // Reset pan start if fewer than two pointers remain
          if (Object.keys(pointerPositions).length < 2) {
            startMidPoint = null;
            startLookAt = null;
          }
          // Clear preview after pointer up
          previewCell = null;
        });

        canvas.addEventListener('pointercancel', (e) => {
          delete pointerPositions[e.pointerId];
          if (e.pointerId === pointerId) {
            pointerId = null;
            isDragging = false;
          }
          // Reset pan start when pointer is canceled
          if (Object.keys(pointerPositions).length < 2) {
            startMidPoint = null;
            startLookAt = null;
          }
          // Clear preview when pointer is canceled
          previewCell = null;
        });

        // Mouse wheel for zoom
        canvas.addEventListener('wheel', (e) => {
          e.preventDefault();
          const delta = e.deltaY;
          camDist += delta * 0.005;
          camDist = Math.max(3, Math.min(20, camDist));
        });

        // Handle tap for placement/removal
        function handleTap(clientX, clientY) {
          const rect = canvas.getBoundingClientRect();
          const x = clientX - rect.left;
          const y = clientY - rect.top;
          // If Fill mode is active, interpret this tap as part of a fill selection.
          if (fillMode) {
            handleFillTap(x, y);
            return;
          }
          // Check if click hits an existing face
          // We'll find the nearest face (last in sorted order is nearest) that contains the point
          // Iterate faces from nearest to farthest (end to start) for correct picking
          for (let i = lastFaces.length - 1; i >= 0; i--) {
            const f = lastFaces[i];
            if (pointInPolygon(x, y, f.pts)) {
              // Determine the block we clicked on
              const block = world.get(f.blockKey);
              if (stackMode) {
                // In stack mode, place a new block adjacent to the clicked face. Treat open doors as empty.
                const [bx, by, bz] = f.blockKey.split(',').map(Number);
                const nx = f.normal.x;
                const ny = f.normal.y;
                const nz = f.normal.z;
                const targetX = bx + nx;
                const targetY = by + ny;
                const targetZ = bz + nz;
                if (targetY >= 0) {
                  const existing = world.get(`${targetX},${targetY},${targetZ}`);
                  const isEmpty = !existing || (existing.type === 'door' && existing.open);
                  if (isEmpty) {
                    placeBlockGroup(targetX, targetY, targetZ);
                  }
                }
              } else {
                // If the block is a door, toggle its open state instead of removing it
                if (block && block.type === 'door') {
                  // Door interaction: if the door is currently open (stored in openDoors), close it
                  if (openDoors.has(f.blockKey)) {
                    const originalBlock = openDoors.get(f.blockKey);
                    world.set(f.blockKey, originalBlock);
                    openDoors.delete(f.blockKey);
                    history.push({ type: 'doorClose', key: f.blockKey });
                  } else {
                    // Door is closed, open it: remove from world and store for later
                    openDoors.set(f.blockKey, block);
                    world.delete(f.blockKey);
                    history.push({ type: 'doorOpen', key: f.blockKey, block });
                    // Opening a door may cause blocks above to fall
                    applyGravity();
                  }
                } else {
                  // Remove block and record action for undo
                  const removedBlock = block;
                  world.delete(f.blockKey);
                  if (removedBlock !== undefined) {
                    history.push({ type: 'remove', blocks: [{ key: f.blockKey, block: removedBlock }] });
                  }
                  // After removal, apply gravity to allow blocks above to settle
                  applyGravity();
                }
              }
              return;
            }
          }
          // Otherwise attempt to place block in front of the camera along the ray.
          // Compute world ray origin (camera position) and direction from screen coordinates.
          const origin = getCameraPos();
          const dir = screenToWorldDirection(x, y);
          // Find first empty voxel along this ray (limited steps).
          const empty = findEmptyCellAlongRay(origin, dir, 100);
          if (empty) {
            // Place a group of blocks anchored to the current camera orientation
            placeBlockGroup(empty.x, empty.y, empty.z);
            return;
          }
          // Fallback: place block on the ground plane if no empty cell found along ray.
          const grid = screenToGridPlane(x, y);
          if (!grid) return;
          const gx = Math.round(grid.x);
          const gz = Math.round(grid.z);
          // Determine the highest occupied Y at this (x,z) and place new block above it
          const h = highestY(gx, gz) + 1 + heightOffset;
          // Place the block group on the ground plane at the adjusted height
          placeBlockGroup(gx, h, gz);
        }

        // Initialize default ground (optional) - start with a small plane
        function initGround(size) {
          const half = Math.floor(size / 2);
          for (let x = -half; x <= half; x++) {
            for (let z = -half; z <= half; z++) {
              world.set(`${x},0,${z}`, { type: 'grass' });
            }
          }
        }

        // Create an initial castle structure at the center of the world.
        // The castle comprises an outer wall, four corner towers and a walkway
        // around the top. Walls are built from stone blocks, towers from
        // brick blocks with roof blocks on top, and a simple gate opening on the
        // front side (negative z direction). Adjust these ranges to change
        // the size or appearance of the castle. The structure is placed at
        // ground level (y=1+) and does not include a floor, allowing you to
        // customize the interior.
        function createCastle() {
          // Outer wall dimensions (from -4 to 4 along both x and z)
          const min = -4;
          const max = 4;
          // Build outer walls at y=1 and y=2 using stone blocks
          for (let x = min; x <= max; x++) {
            for (let z = min; z <= max; z++) {
              // Determine if this position is on the perimeter
              const onPerimeter = (x === min || x === max || z === min || z === max);
              if (onPerimeter) {
                // Leave a gate opening on the front side (z == min) between x=-1 and x=1
                if (z === min && x >= -1 && x <= 1) {
                  continue;
                }
                // Build the wall two blocks high
                for (let y = 1; y <= 2; y++) {
                  world.set(`${x},${y},${z}`, { type: 'stone' });
                }
              }
            }
          }
          // Define the coordinates for four corner towers. Each tower covers
          // a 2×2 footprint and rises four blocks high with a roof on top.
          const towerRanges = [
            { xs: [-4, -3], zs: [-4, -3] },
            { xs: [-4, -3], zs: [3, 4] },
            { xs: [3, 4], zs: [-4, -3] },
            { xs: [3, 4], zs: [3, 4] },
          ];
          towerRanges.forEach(({ xs, zs }) => {
            for (let x = xs[0]; x <= xs[1]; x++) {
              for (let z = zs[0]; z <= zs[1]; z++) {
                // Build tower body up to y=4 with brick
                for (let y = 1; y <= 4; y++) {
                  world.set(`${x},${y},${z}`, { type: 'brick' });
                }
                // Add a roof block on top at y=5
                world.set(`${x},5,${z}`, { type: 'roof' });
              }
            }
          });
          // Construct a walkway at y=3 along the inner perimeter of the wall using stone
          for (let x = min + 1; x <= max - 1; x++) {
            // Front and back walls
            world.set(`${x},3,${min}`, { type: 'stone' });
            world.set(`${x},3,${max}`, { type: 'stone' });
          }
          for (let z = min + 1; z <= max - 1; z++) {
            // Left and right walls
            world.set(`${min},3,${z}`, { type: 'stone' });
            world.set(`${max},3,${z}`, { type: 'stone' });
          }
        }
        // Initialize a larger ground plane so we have room for a starting castle. Use
        // a larger size (15) instead of the default 5. This creates a flat grassy
        // surface from -7 to 7 in both x and z directions.
        initGround(15);

        // Build an initial castle at the center of the world. The castle uses
        // stone walls, brick towers, and a roof for the tower tops. See
        // createCastle() definition below. After constructing the castle,
        // automatically zoom the camera to fit all of its blocks in view so it
        // appears centered on load.
        createCastle();
        zoomToExtent();
        // Sync the zoom slider with the computed camera distance so the slider
        // reflects the current zoom level. Without this, the slider retains its
        // default value even after zoomToExtent() adjusts camDist.
        if (zoomSlider) {
          zoomSlider.value = String(camDist);
        }

        status.textContent = 'Ready';
        // Initialize height display
        updateHeightDisplay();
        // Initialize the tilt slider to reflect the default pitch value (convert radians to degrees)
        if (tiltSlider) {
          tiltSlider.value = String(Math.round(pitch * 180 / Math.PI));
        }
        // Show camera prompt initially so the user knows to enable AR
        showCameraPrompt();
      })();
    </script>
    <!--
      How to run:
      - Save this HTML file and open it in any modern web browser on desktop or mobile.
      - It will request camera permissions for an AR-style background; if declined or unavailable, a gradient background is shown.
      - On mobile, touch and drag to rotate the view. Pinch to zoom in/out. Tap on an existing cube to remove it. Tap in empty space to place new blocks; if a free cell is found in front of you it will appear in the air, otherwise it will be placed on the ground. You can also place larger areas (2×2 or 3×3) by selecting the size on the toolbar.
      - On desktop, use mouse drag to rotate, mouse wheel to zoom, and click to place or remove blocks as above.
      - Use the toolbar at the bottom to select block types (Grass, Stone, Glass, Wood, Brick, Road), placement sizes (1×1, 2×2, 3×3), reset the world (which resets the ground plane), or zoom to the extent of all placed voxels.
      - Additional buttons let you undo the most recent action, save the current world to localStorage, load a previously saved world, and toggle grid lines on the ground plane. Height controls (±) adjust the vertical offset when placing blocks on the ground plane, enabling multi‑level structures.
      - You can pan the scene by dragging with two fingers (or two pointers), allowing you to move around the world; pinch to zoom still works.
      - A faint preview block or group appears under your finger to show exactly where the next block(s) will be placed. Multi‑block previews respect your selected size.
      - Blocks placed in mid‑air are anchored to your current viewing direction. They will only appear again when you point the device back toward the same real‑world direction, simulating AR persistence. Use grid lines and orientation cues to orient yourself.
      Limitations:
      - This demo runs entirely in 2D canvas with a simple custom renderer, so performance decreases with many blocks or very large cities. Keep the number of blocks reasonable.
      - Without true WebXR support and spatial tracking, the game relies solely on your viewing direction for persistence; moving physically around will not anchor blocks to absolute positions.
    -->
  </body>
</html>